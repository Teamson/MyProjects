{
  "code": "import WxApi from \"../Libs/WxApi\";\r\nexport default class Utility {\r\n    static calcDistance(a, b) {\r\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n    }\r\n    static getWorldDis(a, b) {\r\n        let pA = a.transform.position.clone();\r\n        let pB = b.transform.position.clone();\r\n        return Laya.Vector3.distance(pA, pB);\r\n    }\r\n    static getDirectionAToB(A, B, normalize = true) {\r\n        let pA = A.transform.position.clone();\r\n        let pB = B.transform.position.clone();\r\n        let dir = new Laya.Vector3(0, 0, 0);\r\n        Laya.Vector3.subtract(pB, pA, dir);\r\n        if (normalize)\r\n            Laya.Vector3.normalize(dir, dir);\r\n        return dir;\r\n    }\r\n    static fixPosY(y, designHeight = 1334) {\r\n        return y * Laya.stage.displayHeight / designHeight;\r\n    }\r\n    static findNodeByName(rootNode, name) {\r\n        let targetNode = null;\r\n        let funC = (node) => {\r\n            for (let i = 0; i < node.numChildren; i++) {\r\n                if (node.getChildAt(i).name == name) {\r\n                    targetNode = node.getChildAt(i);\r\n                    return;\r\n                }\r\n                else {\r\n                    funC(node.getChildAt(i));\r\n                }\r\n            }\r\n        };\r\n        funC(rootNode);\r\n        return targetNode;\r\n    }\r\n    static TmoveTo(node, duration, des, cb, ease) {\r\n        if (!node.transform)\r\n            return;\r\n        let t = new Laya.Tween();\r\n        var posOld = node.transform.position;\r\n        t.to(node.transform.position, {\r\n            x: des.x,\r\n            y: des.y,\r\n            z: des.z,\r\n            update: new Laya.Handler(this, () => {\r\n                if (!node.transform)\r\n                    return;\r\n                node.transform.position = posOld;\r\n            })\r\n        }, duration, ease, Laya.Handler.create(this, () => {\r\n            cb && cb();\r\n        }));\r\n    }\r\n    static TmoveToYZ(node, duration, des, cb, ease) {\r\n        if (!node.transform)\r\n            return;\r\n        let t = new Laya.Tween();\r\n        var posOld = node.transform.position;\r\n        t.to(node.transform.position, {\r\n            y: des.y,\r\n            z: des.z,\r\n            update: new Laya.Handler(this, () => {\r\n                if (node.transform)\r\n                    node.transform.position = posOld;\r\n            })\r\n        }, duration, null, Laya.Handler.create(this, () => {\r\n            cb && cb();\r\n        }));\r\n        return t;\r\n    }\r\n    static TmoveToX(node, duration, des, cb, ease) {\r\n        if (!node.transform)\r\n            return;\r\n        let t = new Laya.Tween();\r\n        var posOld = node.transform.localPosition;\r\n        t.to(node.transform.localPosition, {\r\n            x: des.x,\r\n            update: new Laya.Handler(this, () => {\r\n                if (node.transform)\r\n                    node.transform.localPosition = posOld;\r\n            })\r\n        }, duration, null, Laya.Handler.create(this, () => {\r\n            cb && cb();\r\n        }));\r\n    }\r\n    static TmoveToY(node, duration, des, cb, ease) {\r\n        if (!node.transform)\r\n            return;\r\n        let t = new Laya.Tween();\r\n        var posOld = node.transform.localPosition;\r\n        t.to(node.transform.localPosition, {\r\n            y: des.y,\r\n            update: new Laya.Handler(this, () => {\r\n                if (node.transform)\r\n                    node.transform.localPosition = posOld;\r\n            })\r\n        }, duration, ease, Laya.Handler.create(this, () => {\r\n            cb && cb();\r\n        }));\r\n    }\r\n    static TmoveToWorld(node, duration, des, cb, ease) {\r\n        if (!node.transform)\r\n            return;\r\n        let t = new Laya.Tween();\r\n        var posOld = node.transform.position;\r\n        t.to(node.transform.position, {\r\n            y: des.y,\r\n            update: new Laya.Handler(this, () => {\r\n                if (node.transform)\r\n                    node.transform.position = posOld;\r\n            })\r\n        }, duration, null, Laya.Handler.create(this, () => {\r\n            cb && cb();\r\n        }));\r\n    }\r\n    static RotateWithPoint(node, dir, angle) {\r\n        let desPos = new Laya.Vector3();\r\n        let p = node.transform.localPosition.clone();\r\n        angle = angle * Math.PI / 180;\r\n        desPos.x = p.x * Math.cos(angle) + (dir.y * p.z - dir.z * p.y) * Math.sin(angle) +\r\n            dir.x * (dir.x * p.x + dir.y * p.y + dir.z * p.z) * (1 - Math.cos(angle));\r\n        desPos.y = p.y * Math.cos(angle) + (dir.x * p.z - dir.z * p.x) * Math.sin(angle) +\r\n            dir.y * (dir.x * p.x + dir.y * p.y + dir.z * p.z) * (1 - Math.cos(angle));\r\n        desPos.z = p.z * Math.cos(angle) + (dir.x * p.y - dir.y * p.x) * Math.sin(angle) +\r\n            dir.z * (dir.x * p.x + dir.y * p.y + dir.z * p.z) * (1 - Math.cos(angle));\r\n        return desPos;\r\n    }\r\n    static RotateTo(node, duration, des, cb) {\r\n        var rotationOld = node.transform.rotationEuler;\r\n        Laya.Tween.to(node.transform.rotationEuler, {\r\n            x: des.x,\r\n            y: des.y,\r\n            z: des.z,\r\n            update: new Laya.Handler(this, function () {\r\n                if (node)\r\n                    node.transform.rotationEuler = rotationOld;\r\n            })\r\n        }, duration, Laya.Ease.cubicOut, Laya.Handler.create(this, function () {\r\n            cb && cb();\r\n        }));\r\n    }\r\n    static tMove2D(node, x, y, t, cb) {\r\n        Laya.Tween.to(node, { x: x, y: y }, t, null, new Laya.Handler(this, () => {\r\n            if (cb)\r\n                cb();\r\n        }));\r\n    }\r\n    static scaleTo2D(node, s, t, cb) {\r\n        Laya.Tween.to(node, { scaleX: s, scaleY: s }, t, null, new Laya.Handler(this, () => {\r\n            if (cb)\r\n                cb();\r\n        }));\r\n    }\r\n    static alphaTo2D(node, s, t, cb) {\r\n        Laya.Tween.to(node, { alpha: s }, t, null, new Laya.Handler(this, () => {\r\n            if (cb)\r\n                cb();\r\n        }));\r\n    }\r\n    static updateNumber(baseNum, times, label, labelOrFont = true, inclease, cb) {\r\n        let timesNum = baseNum * times;\r\n        let dt = Math.floor((timesNum - baseNum) / 60);\r\n        dt = dt <= 0 ? 1 : dt;\r\n        let func = () => {\r\n            if (inclease) {\r\n                baseNum += dt;\r\n                if (baseNum >= timesNum) {\r\n                    baseNum = timesNum;\r\n                    cb && cb();\r\n                    Laya.timer.clear(this, func);\r\n                }\r\n                if (labelOrFont)\r\n                    label.text = baseNum.toString();\r\n                else\r\n                    label.value = baseNum.toString();\r\n            }\r\n            else {\r\n                timesNum -= dt;\r\n                if (timesNum <= baseNum) {\r\n                    timesNum = baseNum;\r\n                    cb && cb();\r\n                    Laya.timer.clear(this, func);\r\n                }\r\n                if (labelOrFont)\r\n                    label.text = timesNum.toString();\r\n                else\r\n                    label.value = timesNum.toString();\r\n            }\r\n        };\r\n        Laya.timer.frameLoop(1, this, func);\r\n    }\r\n    static loadJson(str, complete) {\r\n        Laya.loader.load(str, Laya.Handler.create(this, complete), null, Laya.Loader.JSON);\r\n    }\r\n    static objectShake(target, shakeTime = 1, shakeAmount = 0.7) {\r\n        var shake = shakeTime;\r\n        var decreaseFactor = 1;\r\n        var originalPos = target.transform.localPosition.clone();\r\n        Laya.timer.frameLoop(1, this, updateShake);\r\n        function randomPos() {\r\n            var x = Math.random() > 0.5 ? Math.random() : -(Math.random());\r\n            var y = Math.random() > 0.5 ? Math.random() : -(Math.random());\r\n            return new Laya.Vector3(x, y, 0);\r\n        }\r\n        function updateShake() {\r\n            if (shake > 0) {\r\n                var pos = new Laya.Vector3();\r\n                Laya.Vector3.scale(randomPos(), shakeAmount, pos);\r\n                Laya.Vector3.add(originalPos, pos, pos);\r\n                target.transform.localPosition = pos;\r\n                shake -= 0.02 * decreaseFactor;\r\n            }\r\n            else {\r\n                shake = 0;\r\n                target.transform.localPosition = originalPos;\r\n                Laya.timer.clear(this, updateShake);\r\n            }\r\n        }\r\n    }\r\n    static getRandomItemInArr(arr) {\r\n        return arr[Math.floor(Math.random() * arr.length)];\r\n    }\r\n    static shuffleArr(arr) {\r\n        let i = arr.length;\r\n        while (i) {\r\n            let j = Math.floor(Math.random() * i--);\r\n            [arr[j], arr[i]] = [arr[i], arr[j]];\r\n        }\r\n        return arr;\r\n    }\r\n    static GetRandom(mix, max, isInt = true) {\r\n        let w = max - mix;\r\n        let r1 = Math.random() * (w + 1);\r\n        r1 += mix;\r\n        return isInt ? Math.floor(r1) : r1;\r\n    }\r\n    static coinCollectAnim(startPos, endPos, parent, amount = 10, callBack) {\r\n        let am = amount;\r\n        for (var i = 0; i < amount; i++) {\r\n            let coin = Laya.Pool.getItemByClass(\"coin\", Laya.Image);\r\n            coin.skin = \"startUI/zy_zs_1.png\";\r\n            coin.x = startPos.x;\r\n            coin.y = startPos.y;\r\n            parent.addChild(coin);\r\n            let time = 300 + Math.random() * 100 - 50;\r\n            Laya.Tween.to(coin, { x: coin.x + Math.random() * 250 - 125, y: coin.y + Math.random() * 250 - 125 }, time);\r\n            Laya.timer.once(time + 50, this, function () {\r\n                Laya.Tween.to(coin, { x: endPos.x, y: endPos.y }, 400, null, new Laya.Handler(this, function () {\r\n                    parent.removeChild(coin);\r\n                    Laya.Pool.recover(\"coin\", coin);\r\n                    am--;\r\n                    if (am == 0 && callBack)\r\n                        callBack();\r\n                }));\r\n            });\r\n        }\r\n    }\r\n    static scaleLoop(node, rate, t) {\r\n        var tw = Laya.Tween.to(node, { scaleX: rate, scaleY: rate }, t, null, new Laya.Handler(this, () => {\r\n            Laya.Tween.to(node, { scaleX: 1, scaleY: 1 }, t, null, new Laya.Handler(this, () => {\r\n                this.scaleLoop(node, rate, t);\r\n            }));\r\n        }));\r\n    }\r\n    static rotateLoop(node, rate, t) {\r\n        var tw = Laya.Tween.to(node, { rotation: rate }, t, null, new Laya.Handler(this, () => {\r\n            Laya.Tween.to(node, { rotation: -rate }, 2 * t, null, new Laya.Handler(this, () => {\r\n                Laya.Tween.to(node, { rotation: 0 }, t, null, new Laya.Handler(this, () => {\r\n                    this.rotateLoop(node, rate, t);\r\n                }));\r\n            }));\r\n        }));\r\n    }\r\n    static visibleDelay(node, duration) {\r\n        node.visible = false;\r\n        Laya.timer.once(duration, this, () => { node.visible = true; });\r\n    }\r\n    static pointInPolygon(point, vs) {\r\n        var x = point.x, y = point.y;\r\n        var inside = false;\r\n        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n            var xi = vs[i].x, yi = vs[i].y;\r\n            var xj = vs[j].x, yj = vs[j].y;\r\n            var intersect = ((yi > y) != (yj > y))\r\n                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n            if (intersect)\r\n                inside = !inside;\r\n        }\r\n        return inside;\r\n    }\r\n    static getSprite3DResByUrl(url, parent, worldPosStays = false) {\r\n        let res = Laya.loader.getRes(WxApi.UnityPath + url);\r\n        return Laya.Sprite3D.instantiate(res, parent, worldPosStays, new Laya.Vector3(0, 0, 0));\r\n    }\r\n    static getRandomItemInArrWithoutSelf(self, arr, count = 1) {\r\n        let temp = [].concat(arr);\r\n        temp.splice(temp.indexOf(self), 1);\r\n        temp = this.shuffleArr(temp);\r\n        return temp.slice(0, count);\r\n    }\r\n    static getBoundBox(node, fix = false) {\r\n        let coll = node.getComponent(Laya.PhysicsCollider);\r\n        let shape = coll.colliderShape;\r\n        let pos = node.transform.position.clone();\r\n        pos.x += shape.localOffset.x;\r\n        pos.y += shape.localOffset.y;\r\n        pos.z += shape.localOffset.z;\r\n        let parent = node.parent;\r\n        let sz = 1;\r\n        if (parent && parent.transform && fix) {\r\n            sz = parent.transform.localScaleZ;\r\n        }\r\n        let min = new Laya.Vector3(pos.x - shape.sizeX / 2, pos.y - shape.sizeY / 2, pos.z - shape.sizeZ / 2);\r\n        let max = new Laya.Vector3(pos.x + shape.sizeX / 2, pos.y + shape.sizeY / 2, pos.z + (shape.sizeZ * sz / 2) / 2);\r\n        return new Laya.BoundBox(min, max);\r\n    }\r\n    static getBoundBoxWithMinMax(min, max) {\r\n        return new Laya.BoundBox(min, max);\r\n    }\r\n    static addClickEvent(btn, caller, callBack, param, isScale) {\r\n        btn.offAllCaller(caller);\r\n        if (btn instanceof Laya.Button && !isScale) {\r\n            let callback = (event) => {\r\n                if (callBack)\r\n                    callBack.call(caller, event);\r\n            };\r\n            btn.on(Laya.Event.CLICK, caller, callback, [param]);\r\n        }\r\n        else {\r\n            let scaleTime = 60;\r\n            let wRatio = 1;\r\n            let scaleX = btn.scaleX * wRatio;\r\n            let scaleY = btn.scaleY * wRatio;\r\n            let size = 0.9 * wRatio;\r\n            let isPressed = false;\r\n            let cbDown = (event) => {\r\n                isPressed = true;\r\n                Laya.Tween.to(btn, { scaleX: size, scaleY: size }, scaleTime);\r\n            };\r\n            btn.on(Laya.Event.MOUSE_DOWN, caller, cbDown, [param]);\r\n            let cbUp = (event) => {\r\n                if (isPressed == false)\r\n                    return;\r\n                isPressed = false;\r\n                Laya.Tween.to(btn, { scaleX: scaleX, scaleY: scaleY }, scaleTime, null, new Laya.Handler(caller, () => {\r\n                    if (callBack)\r\n                        callBack.call(caller, event);\r\n                }));\r\n            };\r\n            btn.on(Laya.Event.MOUSE_UP, caller, cbUp, [param]);\r\n            let cbOut = (event) => {\r\n                Laya.Tween.to(btn, { scaleX: scaleX, scaleY: scaleY }, scaleTime);\r\n            };\r\n            btn.on(Laya.Event.MOUSE_OUT, caller, cbOut, [param]);\r\n        }\r\n    }\r\n    static getVector3(x, y, z) {\r\n        return new Laya.Vector3(Number(x), Number(y), Number(z));\r\n    }\r\n}\r\n",
  "references": [
    "E:/FDProjects/Projects/Mosquito-wzdzz/src/Libs/WxApi.ts",
    "E:/FDProjects/Projects/Mosquito-wzdzz/src/Mod/SoundMgr.ts"
  ]
}
